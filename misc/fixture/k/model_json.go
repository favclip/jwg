// generated by jwg -output misc/fixture/k/model_json.go misc/fixture/k; DO NOT EDIT

package k

import (
	"encoding/json"
	o1 "github.com/favclip/jwg/misc/other/v1"
	o2 "github.com/favclip/jwg/misc/other/v2"
)

// for Foo
type FooJson struct {
	Test *o1.Test `json:"test,omitempty"`
}

type FooJsonList []*FooJson

type FooPropertyEncoder func(src *Foo, dest *FooJson) error

type FooPropertyDecoder func(src *FooJson, dest *Foo) error

type FooPropertyInfo struct {
	name    string
	Encoder FooPropertyEncoder
	Decoder FooPropertyDecoder
}

type FooJsonBuilder struct {
	_properties map[string]*FooPropertyInfo
	Test        *FooPropertyInfo
}

func NewFooJsonBuilder() *FooJsonBuilder {
	return &FooJsonBuilder{
		_properties: map[string]*FooPropertyInfo{},
		Test: &FooPropertyInfo{
			name: "Test",
			Encoder: func(src *Foo, dest *FooJson) error {
				if src == nil {
					return nil
				}
				dest.Test = src.Test
				return nil
			},
			Decoder: func(src *FooJson, dest *Foo) error {
				if src == nil {
					return nil
				}
				dest.Test = src.Test
				return nil
			},
		},
	}
}

func (b *FooJsonBuilder) AddAll() *FooJsonBuilder {
	b._properties["Test"] = b.Test
	return b
}

func (b *FooJsonBuilder) Add(info *FooPropertyInfo) *FooJsonBuilder {
	b._properties[info.name] = info
	return b
}

func (b *FooJsonBuilder) Remove(info *FooPropertyInfo) *FooJsonBuilder {
	delete(b._properties, info.name)
	return b
}

func (b *FooJsonBuilder) Convert(orig *Foo) (*FooJson, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &FooJson{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (b *FooJsonBuilder) ConvertList(orig []*Foo) (FooJsonList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(FooJsonList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

func (orig *FooJson) Convert() (*Foo, error) {
	ret := &Foo{}

	b := NewFooJsonBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (jsonList FooJsonList) Convert() ([]*Foo, error) {
	orig := ([]*FooJson)(jsonList)

	list := make([]*Foo, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

func (b *FooJsonBuilder) Marshal(orig *Foo) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}

// for Bar
type BarJson struct {
	Tests []*o2.Test `json:"tests,omitempty"`
}

type BarJsonList []*BarJson

type BarPropertyEncoder func(src *Bar, dest *BarJson) error

type BarPropertyDecoder func(src *BarJson, dest *Bar) error

type BarPropertyInfo struct {
	name    string
	Encoder BarPropertyEncoder
	Decoder BarPropertyDecoder
}

type BarJsonBuilder struct {
	_properties map[string]*BarPropertyInfo
	Tests       *BarPropertyInfo
}

func NewBarJsonBuilder() *BarJsonBuilder {
	return &BarJsonBuilder{
		_properties: map[string]*BarPropertyInfo{},
		Tests: &BarPropertyInfo{
			name: "Tests",
			Encoder: func(src *Bar, dest *BarJson) error {
				if src == nil {
					return nil
				}
				dest.Tests = src.Tests
				return nil
			},
			Decoder: func(src *BarJson, dest *Bar) error {
				if src == nil {
					return nil
				}
				dest.Tests = src.Tests
				return nil
			},
		},
	}
}

func (b *BarJsonBuilder) AddAll() *BarJsonBuilder {
	b._properties["Tests"] = b.Tests
	return b
}

func (b *BarJsonBuilder) Add(info *BarPropertyInfo) *BarJsonBuilder {
	b._properties[info.name] = info
	return b
}

func (b *BarJsonBuilder) Remove(info *BarPropertyInfo) *BarJsonBuilder {
	delete(b._properties, info.name)
	return b
}

func (b *BarJsonBuilder) Convert(orig *Bar) (*BarJson, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &BarJson{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (b *BarJsonBuilder) ConvertList(orig []*Bar) (BarJsonList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(BarJsonList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

func (orig *BarJson) Convert() (*Bar, error) {
	ret := &Bar{}

	b := NewBarJsonBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (jsonList BarJsonList) Convert() ([]*Bar, error) {
	orig := ([]*BarJson)(jsonList)

	list := make([]*Bar, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

func (b *BarJsonBuilder) Marshal(orig *Bar) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}
