// generated by jwg -output misc/fixture/k/model_json.go misc/fixture/k; DO NOT EDIT

package k

import (
	"encoding/json"
	o1 "github.com/favclip/jwg/misc/other/v1"
	o2 "github.com/favclip/jwg/misc/other/v2"
)

// FooJSON is jsonized struct for Foo.
type FooJSON struct {
	Test *o1.Test `json:"test,omitempty"`
}

// FooJSONList is synonym about []*FooJSON.
type FooJSONList []*FooJSON

// FooPropertyEncoder is property encoder for [1]sJSON.
type FooPropertyEncoder func(src *Foo, dest *FooJSON) error

// FooPropertyDecoder is property decoder for [1]sJSON.
type FooPropertyDecoder func(src *FooJSON, dest *Foo) error

// FooPropertyInfo stores property information.
type FooPropertyInfo struct {
	name    string
	Encoder FooPropertyEncoder
	Decoder FooPropertyDecoder
}

// FooJSONBuilder convert between Foo to FooJSON mutually.
type FooJSONBuilder struct {
	_properties map[string]*FooPropertyInfo
	Test        *FooPropertyInfo
}

// NewFooJSONBuilder make new FooJSONBuilder.
func NewFooJSONBuilder() *FooJSONBuilder {
	return &FooJSONBuilder{
		_properties: map[string]*FooPropertyInfo{},
		Test: &FooPropertyInfo{
			name: "Test",
			Encoder: func(src *Foo, dest *FooJSON) error {
				if src == nil {
					return nil
				}
				dest.Test = src.Test
				return nil
			},
			Decoder: func(src *FooJSON, dest *Foo) error {
				if src == nil {
					return nil
				}
				dest.Test = src.Test
				return nil
			},
		},
	}
}

// AddAll adds all property to FooJSONBuilder.
func (b *FooJSONBuilder) AddAll() *FooJSONBuilder {
	b._properties["Test"] = b.Test
	return b
}

// Add specified property to FooJSONBuilder.
func (b *FooJSONBuilder) Add(info *FooPropertyInfo) *FooJSONBuilder {
	b._properties[info.name] = info
	return b
}

// Remove specified property to FooJSONBuilder.
func (b *FooJSONBuilder) Remove(info *FooPropertyInfo) *FooJSONBuilder {
	delete(b._properties, info.name)
	return b
}

// Convert specified non-JSON object to JSON object.
func (b *FooJSONBuilder) Convert(orig *Foo) (*FooJSON, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &FooJSON{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// ConvertList specified non-JSON slice to JSONList.
func (b *FooJSONBuilder) ConvertList(orig []*Foo) (FooJSONList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(FooJSONList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

// Convert specified JSON object to non-JSON object.
func (orig *FooJSON) Convert() (*Foo, error) {
	ret := &Foo{}

	b := NewFooJSONBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Convert specified JSONList to non-JSON slice.
func (jsonList FooJSONList) Convert() ([]*Foo, error) {
	orig := ([]*FooJSON)(jsonList)

	list := make([]*Foo, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

// Marshal non-JSON object to JSON string.
func (b *FooJSONBuilder) Marshal(orig *Foo) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}

// BarJSON is jsonized struct for Bar.
type BarJSON struct {
	Tests []*o2.Test `json:"tests,omitempty"`
}

// BarJSONList is synonym about []*BarJSON.
type BarJSONList []*BarJSON

// BarPropertyEncoder is property encoder for [1]sJSON.
type BarPropertyEncoder func(src *Bar, dest *BarJSON) error

// BarPropertyDecoder is property decoder for [1]sJSON.
type BarPropertyDecoder func(src *BarJSON, dest *Bar) error

// BarPropertyInfo stores property information.
type BarPropertyInfo struct {
	name    string
	Encoder BarPropertyEncoder
	Decoder BarPropertyDecoder
}

// BarJSONBuilder convert between Bar to BarJSON mutually.
type BarJSONBuilder struct {
	_properties map[string]*BarPropertyInfo
	Tests       *BarPropertyInfo
}

// NewBarJSONBuilder make new BarJSONBuilder.
func NewBarJSONBuilder() *BarJSONBuilder {
	return &BarJSONBuilder{
		_properties: map[string]*BarPropertyInfo{},
		Tests: &BarPropertyInfo{
			name: "Tests",
			Encoder: func(src *Bar, dest *BarJSON) error {
				if src == nil {
					return nil
				}
				dest.Tests = src.Tests
				return nil
			},
			Decoder: func(src *BarJSON, dest *Bar) error {
				if src == nil {
					return nil
				}
				dest.Tests = src.Tests
				return nil
			},
		},
	}
}

// AddAll adds all property to BarJSONBuilder.
func (b *BarJSONBuilder) AddAll() *BarJSONBuilder {
	b._properties["Tests"] = b.Tests
	return b
}

// Add specified property to BarJSONBuilder.
func (b *BarJSONBuilder) Add(info *BarPropertyInfo) *BarJSONBuilder {
	b._properties[info.name] = info
	return b
}

// Remove specified property to BarJSONBuilder.
func (b *BarJSONBuilder) Remove(info *BarPropertyInfo) *BarJSONBuilder {
	delete(b._properties, info.name)
	return b
}

// Convert specified non-JSON object to JSON object.
func (b *BarJSONBuilder) Convert(orig *Bar) (*BarJSON, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &BarJSON{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// ConvertList specified non-JSON slice to JSONList.
func (b *BarJSONBuilder) ConvertList(orig []*Bar) (BarJSONList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(BarJSONList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

// Convert specified JSON object to non-JSON object.
func (orig *BarJSON) Convert() (*Bar, error) {
	ret := &Bar{}

	b := NewBarJSONBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Convert specified JSONList to non-JSON slice.
func (jsonList BarJSONList) Convert() ([]*Bar, error) {
	orig := ([]*BarJSON)(jsonList)

	list := make([]*Bar, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

// Marshal non-JSON object to JSON string.
func (b *BarJSONBuilder) Marshal(orig *Bar) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}
