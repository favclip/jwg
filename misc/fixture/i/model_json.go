// generated by jwg -output misc/fixture/i/model_json.go misc/fixture/i; DO NOT EDIT

package i

import (
	"encoding/json"
)

// PersonJSON is jsonized struct for Person.
type PersonJSON struct {
	Name     string `json:"name,omitempty"`
	Age      int    `json:"age,omitempty"`
	Password string `json:"password,omitempty"`
}

// PersonJSONList is synonym about []*PersonJSON.
type PersonJSONList []*PersonJSON

// PersonPropertyEncoder is property encoder for [1]sJSON.
type PersonPropertyEncoder func(src *Person, dest *PersonJSON) error

// PersonPropertyDecoder is property decoder for [1]sJSON.
type PersonPropertyDecoder func(src *PersonJSON, dest *Person) error

// PersonPropertyInfo stores property information.
type PersonPropertyInfo struct {
	fieldName string
	jsonName  string
	Encoder   PersonPropertyEncoder
	Decoder   PersonPropertyDecoder
}

// FieldName returns struct field name of property.
func (info *PersonPropertyInfo) FieldName() string {
	return info.fieldName
}

// JSONName returns json field name of property.
func (info *PersonPropertyInfo) JSONName() string {
	return info.jsonName
}

// PersonJSONBuilder convert between Person to PersonJSON mutually.
type PersonJSONBuilder struct {
	_properties        map[string]*PersonPropertyInfo
	_jsonPropertyMap   map[string]*PersonPropertyInfo
	_structPropertyMap map[string]*PersonPropertyInfo
	Name               *PersonPropertyInfo
	Age                *PersonPropertyInfo
	Password           *PersonPropertyInfo
}

// NewPersonJSONBuilder make new PersonJSONBuilder.
func NewPersonJSONBuilder() *PersonJSONBuilder {
	jb := &PersonJSONBuilder{
		_properties:        map[string]*PersonPropertyInfo{},
		_jsonPropertyMap:   map[string]*PersonPropertyInfo{},
		_structPropertyMap: map[string]*PersonPropertyInfo{},
		Name: &PersonPropertyInfo{
			fieldName: "Name",
			jsonName:  "name",
			Encoder: func(src *Person, dest *PersonJSON) error {
				if src == nil {
					return nil
				}
				dest.Name = src.Name
				return nil
			},
			Decoder: func(src *PersonJSON, dest *Person) error {
				if src == nil {
					return nil
				}
				dest.Name = src.Name
				return nil
			},
		},
		Age: &PersonPropertyInfo{
			fieldName: "Age",
			jsonName:  "age",
			Encoder: func(src *Person, dest *PersonJSON) error {
				if src == nil {
					return nil
				}
				dest.Age = src.Age
				return nil
			},
			Decoder: func(src *PersonJSON, dest *Person) error {
				if src == nil {
					return nil
				}
				dest.Age = src.Age
				return nil
			},
		},
		Password: &PersonPropertyInfo{
			fieldName: "Password",
			jsonName:  "password",
			Encoder: func(src *Person, dest *PersonJSON) error {
				if src == nil {
					return nil
				}
				dest.Password = src.Password
				return nil
			},
			Decoder: func(src *PersonJSON, dest *Person) error {
				if src == nil {
					return nil
				}
				dest.Password = src.Password
				return nil
			},
		},
	}
	jb._structPropertyMap["Name"] = jb.Name
	jb._jsonPropertyMap["name"] = jb.Name
	jb._structPropertyMap["Age"] = jb.Age
	jb._jsonPropertyMap["age"] = jb.Age
	jb._structPropertyMap["Password"] = jb.Password
	jb._jsonPropertyMap["password"] = jb.Password
	return jb
}

// Properties returns all properties on PersonJSONBuilder.
func (b *PersonJSONBuilder) Properties() []*PersonPropertyInfo {
	return []*PersonPropertyInfo{
		b.Name,
		b.Age,
		b.Password,
	}
}

// AddAll adds all property to PersonJSONBuilder.
func (b *PersonJSONBuilder) AddAll() *PersonJSONBuilder {
	b._properties["Name"] = b.Name
	b._properties["Age"] = b.Age
	b._properties["Password"] = b.Password
	return b
}

// Add specified property to PersonJSONBuilder.
func (b *PersonJSONBuilder) Add(info *PersonPropertyInfo) *PersonJSONBuilder {
	b._properties[info.fieldName] = info
	return b
}

// AddByJSONNames add properties to PersonJSONBuilder by JSON property name. if name is not in the builder, it will ignore.
func (b *PersonJSONBuilder) AddByJSONNames(names ...string) *PersonJSONBuilder {
	for _, name := range names {
		info := b._jsonPropertyMap[name]
		if info == nil {
			continue
		}
		b._properties[info.fieldName] = info
	}
	return b
}

// AddByNames add properties to PersonJSONBuilder by struct property name. if name is not in the builder, it will ignore.
func (b *PersonJSONBuilder) AddByNames(names ...string) *PersonJSONBuilder {
	for _, name := range names {
		info := b._structPropertyMap[name]
		if info == nil {
			continue
		}
		b._properties[info.fieldName] = info
	}
	return b
}

// Remove specified property to PersonJSONBuilder.
func (b *PersonJSONBuilder) Remove(info *PersonPropertyInfo) *PersonJSONBuilder {
	delete(b._properties, info.fieldName)
	return b
}

// RemoveByJSONNames remove properties to PersonJSONBuilder by JSON property name. if name is not in the builder, it will ignore.
func (b *PersonJSONBuilder) RemoveByJSONNames(names ...string) *PersonJSONBuilder {

	for _, name := range names {
		info := b._jsonPropertyMap[name]
		if info == nil {
			continue
		}
		delete(b._properties, info.fieldName)
	}
	return b
}

// RemoveByNames remove properties to PersonJSONBuilder by struct property name. if name is not in the builder, it will ignore.
func (b *PersonJSONBuilder) RemoveByNames(names ...string) *PersonJSONBuilder {
	for _, name := range names {
		info := b._structPropertyMap[name]
		if info == nil {
			continue
		}
		delete(b._properties, info.fieldName)
	}
	return b
}

// Convert specified non-JSON object to JSON object.
func (b *PersonJSONBuilder) Convert(orig *Person) (*PersonJSON, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &PersonJSON{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// ConvertList specified non-JSON slice to JSONList.
func (b *PersonJSONBuilder) ConvertList(orig []*Person) (PersonJSONList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(PersonJSONList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

// Convert specified JSON object to non-JSON object.
func (orig *PersonJSON) Convert() (*Person, error) {
	ret := &Person{}

	b := NewPersonJSONBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Convert specified JSONList to non-JSON slice.
func (jsonList PersonJSONList) Convert() ([]*Person, error) {
	orig := ([]*PersonJSON)(jsonList)

	list := make([]*Person, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

// Marshal non-JSON object to JSON string.
func (b *PersonJSONBuilder) Marshal(orig *Person) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}

// PeopleJSON is jsonized struct for People.
type PeopleJSON struct {
	ShowPrivateInfo bool          `json:"showPrivateInfo,omitempty"`
	List            []*PersonJSON `json:"list,omitempty"`
}

// PeopleJSONList is synonym about []*PeopleJSON.
type PeopleJSONList []*PeopleJSON

// PeoplePropertyEncoder is property encoder for [1]sJSON.
type PeoplePropertyEncoder func(src *People, dest *PeopleJSON) error

// PeoplePropertyDecoder is property decoder for [1]sJSON.
type PeoplePropertyDecoder func(src *PeopleJSON, dest *People) error

// PeoplePropertyInfo stores property information.
type PeoplePropertyInfo struct {
	fieldName string
	jsonName  string
	Encoder   PeoplePropertyEncoder
	Decoder   PeoplePropertyDecoder
}

// FieldName returns struct field name of property.
func (info *PeoplePropertyInfo) FieldName() string {
	return info.fieldName
}

// JSONName returns json field name of property.
func (info *PeoplePropertyInfo) JSONName() string {
	return info.jsonName
}

// PeopleJSONBuilder convert between People to PeopleJSON mutually.
type PeopleJSONBuilder struct {
	_properties        map[string]*PeoplePropertyInfo
	_jsonPropertyMap   map[string]*PeoplePropertyInfo
	_structPropertyMap map[string]*PeoplePropertyInfo
	ShowPrivateInfo    *PeoplePropertyInfo
	List               *PeoplePropertyInfo
}

// NewPeopleJSONBuilder make new PeopleJSONBuilder.
func NewPeopleJSONBuilder() *PeopleJSONBuilder {
	jb := &PeopleJSONBuilder{
		_properties:        map[string]*PeoplePropertyInfo{},
		_jsonPropertyMap:   map[string]*PeoplePropertyInfo{},
		_structPropertyMap: map[string]*PeoplePropertyInfo{},
		ShowPrivateInfo: &PeoplePropertyInfo{
			fieldName: "ShowPrivateInfo",
			jsonName:  "showPrivateInfo",
			Encoder: func(src *People, dest *PeopleJSON) error {
				if src == nil {
					return nil
				}
				dest.ShowPrivateInfo = src.ShowPrivateInfo
				return nil
			},
			Decoder: func(src *PeopleJSON, dest *People) error {
				if src == nil {
					return nil
				}
				dest.ShowPrivateInfo = src.ShowPrivateInfo
				return nil
			},
		},
		List: &PeoplePropertyInfo{
			fieldName: "List",
			jsonName:  "list",
			Encoder: func(src *People, dest *PeopleJSON) error {
				if src == nil {
					return nil
				}
				list, err := NewPersonJSONBuilder().AddAll().ConvertList(src.List)
				if err != nil {
					return err
				}
				dest.List = ([]*PersonJSON)(list)
				return nil
			},
			Decoder: func(src *PeopleJSON, dest *People) error {
				if src == nil {
					return nil
				}
				list := make([]*Person, len(src.List))
				for idx, obj := range src.List {
					if obj == nil {
						continue
					}
					d, err := obj.Convert()
					if err != nil {
						return err
					}
					list[idx] = d
				}
				dest.List = list
				return nil
			},
		},
	}
	jb._structPropertyMap["ShowPrivateInfo"] = jb.ShowPrivateInfo
	jb._jsonPropertyMap["showPrivateInfo"] = jb.ShowPrivateInfo
	jb._structPropertyMap["List"] = jb.List
	jb._jsonPropertyMap["list"] = jb.List
	return jb
}

// Properties returns all properties on PeopleJSONBuilder.
func (b *PeopleJSONBuilder) Properties() []*PeoplePropertyInfo {
	return []*PeoplePropertyInfo{
		b.ShowPrivateInfo,
		b.List,
	}
}

// AddAll adds all property to PeopleJSONBuilder.
func (b *PeopleJSONBuilder) AddAll() *PeopleJSONBuilder {
	b._properties["ShowPrivateInfo"] = b.ShowPrivateInfo
	b._properties["List"] = b.List
	return b
}

// Add specified property to PeopleJSONBuilder.
func (b *PeopleJSONBuilder) Add(info *PeoplePropertyInfo) *PeopleJSONBuilder {
	b._properties[info.fieldName] = info
	return b
}

// AddByJSONNames add properties to PeopleJSONBuilder by JSON property name. if name is not in the builder, it will ignore.
func (b *PeopleJSONBuilder) AddByJSONNames(names ...string) *PeopleJSONBuilder {
	for _, name := range names {
		info := b._jsonPropertyMap[name]
		if info == nil {
			continue
		}
		b._properties[info.fieldName] = info
	}
	return b
}

// AddByNames add properties to PeopleJSONBuilder by struct property name. if name is not in the builder, it will ignore.
func (b *PeopleJSONBuilder) AddByNames(names ...string) *PeopleJSONBuilder {
	for _, name := range names {
		info := b._structPropertyMap[name]
		if info == nil {
			continue
		}
		b._properties[info.fieldName] = info
	}
	return b
}

// Remove specified property to PeopleJSONBuilder.
func (b *PeopleJSONBuilder) Remove(info *PeoplePropertyInfo) *PeopleJSONBuilder {
	delete(b._properties, info.fieldName)
	return b
}

// RemoveByJSONNames remove properties to PeopleJSONBuilder by JSON property name. if name is not in the builder, it will ignore.
func (b *PeopleJSONBuilder) RemoveByJSONNames(names ...string) *PeopleJSONBuilder {

	for _, name := range names {
		info := b._jsonPropertyMap[name]
		if info == nil {
			continue
		}
		delete(b._properties, info.fieldName)
	}
	return b
}

// RemoveByNames remove properties to PeopleJSONBuilder by struct property name. if name is not in the builder, it will ignore.
func (b *PeopleJSONBuilder) RemoveByNames(names ...string) *PeopleJSONBuilder {
	for _, name := range names {
		info := b._structPropertyMap[name]
		if info == nil {
			continue
		}
		delete(b._properties, info.fieldName)
	}
	return b
}

// Convert specified non-JSON object to JSON object.
func (b *PeopleJSONBuilder) Convert(orig *People) (*PeopleJSON, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &PeopleJSON{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// ConvertList specified non-JSON slice to JSONList.
func (b *PeopleJSONBuilder) ConvertList(orig []*People) (PeopleJSONList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(PeopleJSONList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

// Convert specified JSON object to non-JSON object.
func (orig *PeopleJSON) Convert() (*People, error) {
	ret := &People{}

	b := NewPeopleJSONBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Convert specified JSONList to non-JSON slice.
func (jsonList PeopleJSONList) Convert() ([]*People, error) {
	orig := ([]*PeopleJSON)(jsonList)

	list := make([]*People, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

// Marshal non-JSON object to JSON string.
func (b *PeopleJSONBuilder) Marshal(orig *People) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}
