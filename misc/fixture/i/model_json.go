// generated by jwg -output misc/fixture/i/model_json.go misc/fixture/i; DO NOT EDIT

package i

import (
	"encoding/json"
)

// PersonJSON is jsonized struct for Person.
type PersonJSON struct {
	Name     string `json:"name,omitempty"`
	Age      int    `json:"age,omitempty"`
	Password string `json:"password,omitempty"`
}

// PersonJSONList is synonym about []*PersonJSON.
type PersonJSONList []*PersonJSON

// PersonPropertyEncoder is property encoder for [1]sJSON.
type PersonPropertyEncoder func(src *Person, dest *PersonJSON) error

// PersonPropertyDecoder is property decoder for [1]sJSON.
type PersonPropertyDecoder func(src *PersonJSON, dest *Person) error

// PersonPropertyInfo stores property information.
type PersonPropertyInfo struct {
	name    string
	Encoder PersonPropertyEncoder
	Decoder PersonPropertyDecoder
}

// PersonJSONBuilder convert between Person to PersonJSON mutually.
type PersonJSONBuilder struct {
	_properties map[string]*PersonPropertyInfo
	Name        *PersonPropertyInfo
	Age         *PersonPropertyInfo
	Password    *PersonPropertyInfo
}

// NewPersonJSONBuilder make new PersonJSONBuilder.
func NewPersonJSONBuilder() *PersonJSONBuilder {
	return &PersonJSONBuilder{
		_properties: map[string]*PersonPropertyInfo{},
		Name: &PersonPropertyInfo{
			name: "Name",
			Encoder: func(src *Person, dest *PersonJSON) error {
				if src == nil {
					return nil
				}
				dest.Name = src.Name
				return nil
			},
			Decoder: func(src *PersonJSON, dest *Person) error {
				if src == nil {
					return nil
				}
				dest.Name = src.Name
				return nil
			},
		},
		Age: &PersonPropertyInfo{
			name: "Age",
			Encoder: func(src *Person, dest *PersonJSON) error {
				if src == nil {
					return nil
				}
				dest.Age = src.Age
				return nil
			},
			Decoder: func(src *PersonJSON, dest *Person) error {
				if src == nil {
					return nil
				}
				dest.Age = src.Age
				return nil
			},
		},
		Password: &PersonPropertyInfo{
			name: "Password",
			Encoder: func(src *Person, dest *PersonJSON) error {
				if src == nil {
					return nil
				}
				dest.Password = src.Password
				return nil
			},
			Decoder: func(src *PersonJSON, dest *Person) error {
				if src == nil {
					return nil
				}
				dest.Password = src.Password
				return nil
			},
		},
	}
}

// AddAll adds all property to PersonJSONBuilder.
func (b *PersonJSONBuilder) AddAll() *PersonJSONBuilder {
	b._properties["Name"] = b.Name
	b._properties["Age"] = b.Age
	b._properties["Password"] = b.Password
	return b
}

// Add specified property to PersonJSONBuilder.
func (b *PersonJSONBuilder) Add(info *PersonPropertyInfo) *PersonJSONBuilder {
	b._properties[info.name] = info
	return b
}

// Remove specified property to PersonJSONBuilder.
func (b *PersonJSONBuilder) Remove(info *PersonPropertyInfo) *PersonJSONBuilder {
	delete(b._properties, info.name)
	return b
}

// Convert specified non-JSON object to JSON object.
func (b *PersonJSONBuilder) Convert(orig *Person) (*PersonJSON, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &PersonJSON{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// ConvertList specified non-JSON slice to JSONList.
func (b *PersonJSONBuilder) ConvertList(orig []*Person) (PersonJSONList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(PersonJSONList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

// Convert specified JSON object to non-JSON object.
func (orig *PersonJSON) Convert() (*Person, error) {
	ret := &Person{}

	b := NewPersonJSONBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Convert specified JSONList to non-JSON slice.
func (jsonList PersonJSONList) Convert() ([]*Person, error) {
	orig := ([]*PersonJSON)(jsonList)

	list := make([]*Person, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

// Marshal non-JSON object to JSON string.
func (b *PersonJSONBuilder) Marshal(orig *Person) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}

// PeopleJSON is jsonized struct for People.
type PeopleJSON struct {
	ShowPrivateInfo bool          `json:"showPrivateInfo,omitempty"`
	List            []*PersonJSON `json:"list,omitempty"`
}

// PeopleJSONList is synonym about []*PeopleJSON.
type PeopleJSONList []*PeopleJSON

// PeoplePropertyEncoder is property encoder for [1]sJSON.
type PeoplePropertyEncoder func(src *People, dest *PeopleJSON) error

// PeoplePropertyDecoder is property decoder for [1]sJSON.
type PeoplePropertyDecoder func(src *PeopleJSON, dest *People) error

// PeoplePropertyInfo stores property information.
type PeoplePropertyInfo struct {
	name    string
	Encoder PeoplePropertyEncoder
	Decoder PeoplePropertyDecoder
}

// PeopleJSONBuilder convert between People to PeopleJSON mutually.
type PeopleJSONBuilder struct {
	_properties     map[string]*PeoplePropertyInfo
	ShowPrivateInfo *PeoplePropertyInfo
	List            *PeoplePropertyInfo
}

// NewPeopleJSONBuilder make new PeopleJSONBuilder.
func NewPeopleJSONBuilder() *PeopleJSONBuilder {
	return &PeopleJSONBuilder{
		_properties: map[string]*PeoplePropertyInfo{},
		ShowPrivateInfo: &PeoplePropertyInfo{
			name: "ShowPrivateInfo",
			Encoder: func(src *People, dest *PeopleJSON) error {
				if src == nil {
					return nil
				}
				dest.ShowPrivateInfo = src.ShowPrivateInfo
				return nil
			},
			Decoder: func(src *PeopleJSON, dest *People) error {
				if src == nil {
					return nil
				}
				dest.ShowPrivateInfo = src.ShowPrivateInfo
				return nil
			},
		},
		List: &PeoplePropertyInfo{
			name: "List",
			Encoder: func(src *People, dest *PeopleJSON) error {
				if src == nil {
					return nil
				}
				list, err := NewPersonJSONBuilder().AddAll().ConvertList(src.List)
				if err != nil {
					return err
				}
				dest.List = ([]*PersonJSON)(list)
				return nil
			},
			Decoder: func(src *PeopleJSON, dest *People) error {
				if src == nil {
					return nil
				}
				list := make([]*Person, len(src.List))
				for idx, obj := range src.List {
					if obj == nil {
						continue
					}
					d, err := obj.Convert()
					if err != nil {
						return err
					}
					list[idx] = d
				}
				dest.List = list
				return nil
			},
		},
	}
}

// AddAll adds all property to PeopleJSONBuilder.
func (b *PeopleJSONBuilder) AddAll() *PeopleJSONBuilder {
	b._properties["ShowPrivateInfo"] = b.ShowPrivateInfo
	b._properties["List"] = b.List
	return b
}

// Add specified property to PeopleJSONBuilder.
func (b *PeopleJSONBuilder) Add(info *PeoplePropertyInfo) *PeopleJSONBuilder {
	b._properties[info.name] = info
	return b
}

// Remove specified property to PeopleJSONBuilder.
func (b *PeopleJSONBuilder) Remove(info *PeoplePropertyInfo) *PeopleJSONBuilder {
	delete(b._properties, info.name)
	return b
}

// Convert specified non-JSON object to JSON object.
func (b *PeopleJSONBuilder) Convert(orig *People) (*PeopleJSON, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &PeopleJSON{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// ConvertList specified non-JSON slice to JSONList.
func (b *PeopleJSONBuilder) ConvertList(orig []*People) (PeopleJSONList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(PeopleJSONList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

// Convert specified JSON object to non-JSON object.
func (orig *PeopleJSON) Convert() (*People, error) {
	ret := &People{}

	b := NewPeopleJSONBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Convert specified JSONList to non-JSON slice.
func (jsonList PeopleJSONList) Convert() ([]*People, error) {
	orig := ([]*PeopleJSON)(jsonList)

	list := make([]*People, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

// Marshal non-JSON object to JSON string.
func (b *PeopleJSONBuilder) Marshal(orig *People) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}
