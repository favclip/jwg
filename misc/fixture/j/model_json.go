// generated by jwg -output misc/fixture/j/model_json.go misc/fixture/j; DO NOT EDIT

package j

import (
	"encoding/json"
)

// for Foo
type FooJson struct {
	Tmp       *Temp `json:"tmp,omitempty"`
	Bar       `json:"bar,omitempty"`
	*Buzz     `json:"buzz,omitempty"`
	HogeJson  `json:"hoge,omitempty"`
	*FugaJson `json:"fuga,omitempty"`
}

type FooJsonList []*FooJson

type FooPropertyEncoder func(src *Foo, dest *FooJson) error

type FooPropertyDecoder func(src *FooJson, dest *Foo) error

type FooPropertyInfo struct {
	name    string
	Encoder FooPropertyEncoder
	Decoder FooPropertyDecoder
}

type FooJsonBuilder struct {
	_properties map[string]*FooPropertyInfo
	Tmp         *FooPropertyInfo
	Bar         *FooPropertyInfo
	Buzz        *FooPropertyInfo
	Hoge        *FooPropertyInfo
	Fuga        *FooPropertyInfo
}

func NewFooJsonBuilder() *FooJsonBuilder {
	return &FooJsonBuilder{
		_properties: map[string]*FooPropertyInfo{},
		Tmp: &FooPropertyInfo{
			name: "Tmp",
			Encoder: func(src *Foo, dest *FooJson) error {
				if src == nil {
					return nil
				}
				dest.Tmp = src.Tmp
				return nil
			},
			Decoder: func(src *FooJson, dest *Foo) error {
				if src == nil {
					return nil
				}
				dest.Tmp = src.Tmp
				return nil
			},
		},
		Bar: &FooPropertyInfo{
			name: "Bar",
			Encoder: func(src *Foo, dest *FooJson) error {
				if src == nil {
					return nil
				}
				dest.Bar = src.Bar
				return nil
			},
			Decoder: func(src *FooJson, dest *Foo) error {
				if src == nil {
					return nil
				}
				dest.Bar = src.Bar
				return nil
			},
		},
		Buzz: &FooPropertyInfo{
			name: "Buzz",
			Encoder: func(src *Foo, dest *FooJson) error {
				if src == nil {
					return nil
				}
				dest.Buzz = src.Buzz
				return nil
			},
			Decoder: func(src *FooJson, dest *Foo) error {
				if src == nil {
					return nil
				}
				dest.Buzz = src.Buzz
				return nil
			},
		},
		Hoge: &FooPropertyInfo{
			name: "Hoge",
			Encoder: func(src *Foo, dest *FooJson) error {
				if src == nil {
					return nil
				}
				d, err := NewHogeJsonBuilder().AddAll().Convert(&src.Hoge)
				if err != nil {
					return err
				}
				dest.HogeJson = *d
				return nil
			},
			Decoder: func(src *FooJson, dest *Foo) error {
				if src == nil {
					return nil
				}
				d, err := src.HogeJson.Convert()
				if err != nil {
					return err
				}
				dest.Hoge = *d
				return nil
			},
		},
		Fuga: &FooPropertyInfo{
			name: "Fuga",
			Encoder: func(src *Foo, dest *FooJson) error {
				if src == nil {
					return nil
				} else if src.Fuga == nil {
					return nil
				}
				d, err := NewFugaJsonBuilder().AddAll().Convert(src.Fuga)
				if err != nil {
					return err
				}
				dest.FugaJson = d
				return nil
			},
			Decoder: func(src *FooJson, dest *Foo) error {
				if src == nil {
					return nil
				} else if src.FugaJson == nil {
					return nil
				}
				d, err := src.FugaJson.Convert()
				if err != nil {
					return err
				}
				dest.Fuga = d
				return nil
			},
		},
	}
}

func (b *FooJsonBuilder) AddAll() *FooJsonBuilder {
	b._properties["Tmp"] = b.Tmp
	b._properties["Bar"] = b.Bar
	b._properties["Buzz"] = b.Buzz
	b._properties["Hoge"] = b.Hoge
	b._properties["Fuga"] = b.Fuga
	return b
}

func (b *FooJsonBuilder) Add(info *FooPropertyInfo) *FooJsonBuilder {
	b._properties[info.name] = info
	return b
}

func (b *FooJsonBuilder) Remove(info *FooPropertyInfo) *FooJsonBuilder {
	delete(b._properties, info.name)
	return b
}

func (b *FooJsonBuilder) Convert(orig *Foo) (*FooJson, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &FooJson{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (b *FooJsonBuilder) ConvertList(orig []*Foo) (FooJsonList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(FooJsonList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

func (orig *FooJson) Convert() (*Foo, error) {
	ret := &Foo{}

	b := NewFooJsonBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (jsonList FooJsonList) Convert() ([]*Foo, error) {
	orig := ([]*FooJson)(jsonList)

	list := make([]*Foo, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

func (b *FooJsonBuilder) Marshal(orig *Foo) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}

// for Hoge
type HogeJson struct {
	Hoge1 string `json:"hoge1,omitempty"`
}

type HogeJsonList []*HogeJson

type HogePropertyEncoder func(src *Hoge, dest *HogeJson) error

type HogePropertyDecoder func(src *HogeJson, dest *Hoge) error

type HogePropertyInfo struct {
	name    string
	Encoder HogePropertyEncoder
	Decoder HogePropertyDecoder
}

type HogeJsonBuilder struct {
	_properties map[string]*HogePropertyInfo
	Hoge1       *HogePropertyInfo
}

func NewHogeJsonBuilder() *HogeJsonBuilder {
	return &HogeJsonBuilder{
		_properties: map[string]*HogePropertyInfo{},
		Hoge1: &HogePropertyInfo{
			name: "Hoge1",
			Encoder: func(src *Hoge, dest *HogeJson) error {
				if src == nil {
					return nil
				}
				dest.Hoge1 = src.Hoge1
				return nil
			},
			Decoder: func(src *HogeJson, dest *Hoge) error {
				if src == nil {
					return nil
				}
				dest.Hoge1 = src.Hoge1
				return nil
			},
		},
	}
}

func (b *HogeJsonBuilder) AddAll() *HogeJsonBuilder {
	b._properties["Hoge1"] = b.Hoge1
	return b
}

func (b *HogeJsonBuilder) Add(info *HogePropertyInfo) *HogeJsonBuilder {
	b._properties[info.name] = info
	return b
}

func (b *HogeJsonBuilder) Remove(info *HogePropertyInfo) *HogeJsonBuilder {
	delete(b._properties, info.name)
	return b
}

func (b *HogeJsonBuilder) Convert(orig *Hoge) (*HogeJson, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &HogeJson{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (b *HogeJsonBuilder) ConvertList(orig []*Hoge) (HogeJsonList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(HogeJsonList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

func (orig *HogeJson) Convert() (*Hoge, error) {
	ret := &Hoge{}

	b := NewHogeJsonBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (jsonList HogeJsonList) Convert() ([]*Hoge, error) {
	orig := ([]*HogeJson)(jsonList)

	list := make([]*Hoge, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

func (b *HogeJsonBuilder) Marshal(orig *Hoge) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}

// for Fuga
type FugaJson struct {
	Fuga1 string `json:"fuga1,omitempty"`
}

type FugaJsonList []*FugaJson

type FugaPropertyEncoder func(src *Fuga, dest *FugaJson) error

type FugaPropertyDecoder func(src *FugaJson, dest *Fuga) error

type FugaPropertyInfo struct {
	name    string
	Encoder FugaPropertyEncoder
	Decoder FugaPropertyDecoder
}

type FugaJsonBuilder struct {
	_properties map[string]*FugaPropertyInfo
	Fuga1       *FugaPropertyInfo
}

func NewFugaJsonBuilder() *FugaJsonBuilder {
	return &FugaJsonBuilder{
		_properties: map[string]*FugaPropertyInfo{},
		Fuga1: &FugaPropertyInfo{
			name: "Fuga1",
			Encoder: func(src *Fuga, dest *FugaJson) error {
				if src == nil {
					return nil
				}
				dest.Fuga1 = src.Fuga1
				return nil
			},
			Decoder: func(src *FugaJson, dest *Fuga) error {
				if src == nil {
					return nil
				}
				dest.Fuga1 = src.Fuga1
				return nil
			},
		},
	}
}

func (b *FugaJsonBuilder) AddAll() *FugaJsonBuilder {
	b._properties["Fuga1"] = b.Fuga1
	return b
}

func (b *FugaJsonBuilder) Add(info *FugaPropertyInfo) *FugaJsonBuilder {
	b._properties[info.name] = info
	return b
}

func (b *FugaJsonBuilder) Remove(info *FugaPropertyInfo) *FugaJsonBuilder {
	delete(b._properties, info.name)
	return b
}

func (b *FugaJsonBuilder) Convert(orig *Fuga) (*FugaJson, error) {
	if orig == nil {
		return nil, nil
	}
	ret := &FugaJson{}

	for _, info := range b._properties {
		if err := info.Encoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (b *FugaJsonBuilder) ConvertList(orig []*Fuga) (FugaJsonList, error) {
	if orig == nil {
		return nil, nil
	}

	list := make(FugaJsonList, len(orig))
	for idx, or := range orig {
		json, err := b.Convert(or)
		if err != nil {
			return nil, err
		}
		list[idx] = json
	}

	return list, nil
}

func (orig *FugaJson) Convert() (*Fuga, error) {
	ret := &Fuga{}

	b := NewFugaJsonBuilder().AddAll()
	for _, info := range b._properties {
		if err := info.Decoder(orig, ret); err != nil {
			return nil, err
		}
	}

	return ret, nil
}

func (jsonList FugaJsonList) Convert() ([]*Fuga, error) {
	orig := ([]*FugaJson)(jsonList)

	list := make([]*Fuga, len(orig))
	for idx, or := range orig {
		obj, err := or.Convert()
		if err != nil {
			return nil, err
		}
		list[idx] = obj
	}

	return list, nil
}

func (b *FugaJsonBuilder) Marshal(orig *Fuga) ([]byte, error) {
	ret, err := b.Convert(orig)
	if err != nil {
		return nil, err
	}
	return json.Marshal(ret)
}
